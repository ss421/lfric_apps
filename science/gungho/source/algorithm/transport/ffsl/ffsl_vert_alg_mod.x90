!-----------------------------------------------------------------------------
! (C) Crown copyright 2023 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module for controlling 1D vertical FFSL steps.
!> @details Solves the 1D transport equation using the flux-form semi-Lagrangian
!!         (FFSL) transport scheme for vertical transport.
module ffsl_vert_alg_mod

  ! Constants and types
  use constants_mod,                    only: r_tran, i_def, l_def
  use fem_constants_mod,                only: get_inverse_w3_mass_matrix, &
                                              get_detj_at_w3_r_tran
  use field_mod,                        only: field_type
  use fs_continuity_mod,                only: W2V
  use function_space_mod,               only: function_space_type
  use function_space_collection_mod,    only: function_space_collection
  use geometric_constants_mod,          only: get_dz_w3
  use log_mod,                          only: log_event, LOG_LEVEL_ERROR
  use mesh_mod,                         only: mesh_type
  use r_tran_field_mod,                 only: r_tran_field_type
  use timer_mod,                        only: timer
  use transport_enumerated_types_mod,   only: equation_form_advective,    &
                                              equation_form_conservative, &
                                              equation_form_consistent,   &
                                              splitting_strang_vhv,       &
                                              direction_v
  use transport_metadata_mod,           only: transport_metadata_type
  use transport_runtime_alg_mod,        only: transport_runtime_type
  use transport_runtime_collection_mod, only: get_transport_runtime

  ! Kernels
  use ffsl_flux_z_constant_kernel_mod,  only: ffsl_flux_z_constant_kernel_type
  use ffsl_flux_z_nirvana_kernel_mod,   only: ffsl_flux_z_nirvana_kernel_type
  use ffsl_flux_z_ppm_kernel_mod,       only: ffsl_flux_z_ppm_kernel_type
  use ffsl_flux_z_rev_nirvana_kernel_mod, &
                                        only: ffsl_flux_z_rev_nirvana_kernel_type
  use fv_difference_z_kernel_mod,       only: fv_difference_z_kernel_type
  use fv_divergence_z_kernel_mod,       only: fv_divergence_z_kernel_type

  ! Configuration options
  use io_config_mod,                    only: subroutine_timers
  use finite_element_config_mod,        only: element_order

  ! PSyKAl-lite code
  use psykal_lite_mod,                  only: invoke_copy_to_rtran
  use psykal_lite_transport_mod,        only: invoke_ffsl_advective_increment, &
                                              invoke_swift_inner_update_tracer

  implicit none

  private

  public :: ffsl_vert_transport_alg
  public :: ffsl_1d_vert_flux_alg

contains


  !> @brief Algorithm for a step of 1D vertical FFSL transport.
  !> @details Solves the 1D transport equation, in either advective or
  !!          conservative form. If needed, the mass flux or field increment
  !!          will be returned.
  !> @param[in,out] mass_flux          Mass flux used to transport the field.
  !> @param[in,out] increment          Increment for the field change over the
  !!                                   time step (per unit time). Only used when
  !!                                   specified through the optional argument
  !> @param[in,out] field_np1          The updated advected field from the time
  !!                                   step. Only used when specified through
  !!                                   the optional logical argument.
  !> @param[in]     field_n            Field at the start of the transport step
  !> @param[in]     step_dt            The dt for this time step
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting this field
  !> @param[in]     order              The reconstruction order to pass to
  !!                                   the underlying vertical flux algorithm
  !> @param[in]     compute_adv_inc    Optional argument as to whether advective
  !!                                   increment should be computed
  !> @param[in]     compute_field_np1  Optional argument as to whether advected
  !!                                   field should be computed
  subroutine ffsl_vert_transport_alg( mass_flux, increment,               &
                                      field_np1, field_n,                 &
                                      step_dt, transport_metadata, order, &
                                      compute_adv_inc, compute_field_np1 )

    implicit none

    ! Arguments ----------------------------------------------------------------
    type(r_tran_field_type),       intent(inout) :: mass_flux
    type(r_tran_field_type),       intent(inout) :: increment
    type(r_tran_field_type),       intent(inout) :: field_np1
    type(r_tran_field_type),       intent(in)    :: field_n
    real(kind=r_tran),             intent(in)    :: step_dt
    type(transport_metadata_type), intent(in)    :: transport_metadata
    integer(kind=i_def),           intent(in)    :: order
    logical(kind=l_def), optional, intent(in)    :: compute_adv_inc
    logical(kind=l_def), optional, intent(in)    :: compute_field_np1

    ! Internal variables -------------------------------------------------------
    ! Pointers to existing objects
    type(transport_runtime_type), pointer :: transport_runtime => null()
    type(mesh_type),              pointer :: mesh => null()
    type(r_tran_field_type),      pointer :: adv_one => null()
    type(r_tran_field_type),      pointer :: detj_at_w3 => null()
    type(r_tran_field_type),      pointer :: dry_mass_n => null()
    type(r_tran_field_type),      pointer :: dry_mass_np1 => null()

    ! Function spaces
    type(function_space_type), pointer :: field_fs => null()

    ! Transport options
    logical(kind=l_def) :: to_compute_adv_inc
    logical(kind=l_def) :: to_compute_field_np1
    logical(kind=l_def) :: strang

    ! Subroutine name for timer
    character(*), parameter :: routine_name = 'transport.ffsl_vertical'

    ! Useful constants
    integer(kind=i_def) :: mesh_id, step
    real(kind=r_tran)   :: one_over_dt

    if ( subroutine_timers ) call timer(routine_name)

    if (present(compute_adv_inc)) then
      to_compute_adv_inc = compute_adv_inc
    else
      to_compute_adv_inc = .true.
    end if

    if (present(compute_field_np1)) then
      to_compute_field_np1 = compute_field_np1
    else
      to_compute_field_np1 = .true.
    end if

    ! Vertical FFSL ------------------------------------------------------------
    call ffsl_1d_vert_flux_alg( mass_flux, field_n, step_dt, &
                                transport_metadata, order )

    ! Compute advected field, if required --------------------------------------
    if (to_compute_adv_inc .or. to_compute_field_np1) then
      ! Get pre-computed objects
      mesh_id = field_n%get_mesh_id()
      mesh => field_n%get_mesh()
      transport_runtime => get_transport_runtime(mesh)
      field_fs => field_n%get_function_space()
      detj_at_w3 => get_detj_at_w3_r_tran(mesh_id)

      step = transport_runtime%get_tracer_step_ctr()
      one_over_dt = 1.0_r_tran / step_dt

      call increment%initialise( vector_space = field_fs )

      select case ( transport_metadata%get_equation_form() )
      case ( equation_form_advective, equation_form_conservative )

        ! Get unity transport
        strang = transport_metadata%get_splitting() == splitting_strang_vhv
        adv_one => transport_runtime%get_adv_unity_z(mesh_id, strang)

        call invoke( fv_divergence_z_kernel_type(increment, mass_flux, detj_at_w3) )
        ! Get the advective increment from these conservative increments
        ! conservative_field_np1 = q - dt * F(q)
        ! adv_one   = 1 - dt * F(1)
        ! inc_part  = q - conservative_field_np1 / adv_one
        ! increment = inc_part / dt
        ! Use psykal lite code to optimise pointwise calculation
        ! @todo #4301: replace this with loop fusion
        call invoke_ffsl_advective_increment(increment, field_n, step_dt, adv_one)

        if (to_compute_field_np1) call invoke( X_minus_bY(field_np1, field_n,  &
                                                          step_dt, increment) )

      case ( equation_form_consistent )

        ! Multiply tracer mixing ratio by dry density to get tracer density
        dry_mass_n => transport_runtime%get_dry_mass(mesh_id, step)
        dry_mass_np1 => transport_runtime%get_dry_mass(mesh_id, step+1)

        call invoke( fv_difference_z_kernel_type(increment, mass_flux) )

        ! Use psykal lite code to optimise the pointwise calculation
        ! @todo #4301: replace this with loop fusion
        call invoke_swift_inner_update_tracer(field_np1, field_n,              &
                                              dry_mass_np1, dry_mass_n,        &
                                              increment, step_dt)

        if (to_compute_adv_inc) then
          ! Increment is really a negative increment, so subtract field_np1
          call invoke( X_minus_Y(increment, field_n, field_np1),               &
                       inc_a_times_X(one_over_dt, increment) )
        end if

      case default
        call log_event( "ffsl_vert_transport_alg: Unrecognized equation form", LOG_LEVEL_ERROR )

      end select
    end if

    nullify( mesh, transport_runtime, field_fs, adv_one, detj_at_w3, &
             dry_mass_n, dry_mass_np1 )

    if ( subroutine_timers ) call timer(routine_name)

  end subroutine ffsl_vert_transport_alg

  !----------------------------------------------------------------------------
  !> @brief   Computes the mass flux associated with a vertical FFSL step.
  !> @details Performs a conservative flux calculation using vertical FFSL.
  !> @param[in,out] mass_flux          Mass flux used to transport the field.
  !> @param[in]     field_n            Field at the start of the transport step
  !> @param[in]     step_dt            The dt for this time step
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting this field
  !> @param[in]     order              The reconstruction order to use
  subroutine ffsl_1d_vert_flux_alg( mass_flux, field_n, step_dt, &
                                    transport_metadata, order )

    implicit none

    ! Arguments ----------------------------------------------------------------
    type(r_tran_field_type),       intent(inout) :: mass_flux
    type(r_tran_field_type),       intent(in)    :: field_n
    real(kind=r_tran),             intent(in)    :: step_dt
    type(transport_metadata_type), intent(in)    :: transport_metadata
    integer(kind=i_def),           intent(in)    :: order

    ! Internal variables -------------------------------------------------------
    ! Pointers to existing objects
    type(transport_runtime_type), pointer :: transport_runtime => null()
    type(mesh_type),              pointer :: mesh => null()
    type(r_tran_field_type),      pointer :: dep_pts_z => null()
    type(r_tran_field_type),      pointer :: frac_wind_or_flux => null()
    type(r_tran_field_type),      pointer :: detj_at_w3 => null()
    type(r_tran_field_type),      pointer :: dry_mass => null()
    type(field_type),             pointer :: dz_w3_rdef => null()

    ! Function spaces
    type(function_space_type), pointer :: field_fs => null()
    type(function_space_type), pointer :: w2v_fs => null()

    ! Transport options
    logical(kind=l_def) :: log_space
    integer(kind=i_def) :: monotone
    logical(kind=l_def) :: reversible
    integer(kind=i_def) :: equation_form
    logical(kind=l_def) :: strang_vhv

    ! Internal fields
    type(r_tran_field_type) :: dz_w3

    ! Useful constants
    integer(kind=i_def) :: mesh_id
    integer(kind=i_def) :: step

    ! Get pre-computed objects and set pointers --------------------------------
    mesh_id = field_n%get_mesh_id()
    mesh => field_n%get_mesh()
    transport_runtime => get_transport_runtime(mesh)

    ! Function spaces
    field_fs => field_n%get_function_space()
    w2v_fs => function_space_collection%get_fs( mesh, element_order, W2V )

    ! Get options
    monotone = transport_metadata%get_vertical_monotone()
    log_space = transport_metadata%get_log_space()
    reversible = transport_metadata%get_reversible()
    equation_form = transport_metadata%get_equation_form()
    strang_vhv = ( transport_metadata%get_splitting() ==  splitting_strang_vhv )


    ! Initialise fields used by all splitting options --------------------------
    call mass_flux%initialise( vector_space = w2v_fs )

    ! Compute low order and integer fluxes -------------------------------------
    select case( equation_form )

    case ( equation_form_conservative, equation_form_advective )
      detj_at_w3 => get_detj_at_w3_r_tran(mesh_id)
      dep_pts_z => transport_runtime%get_dep_dist_z_w2(mesh_id, strang_vhv)
      frac_wind_or_flux => transport_runtime%get_frac_wind_z(mesh_id, strang_vhv)

    case ( equation_form_consistent )
      ! No need to take Strang into account for tracer departure points, as this
      ! should already be factored into the departure points
      step = transport_runtime%get_tracer_step_ctr()
      dep_pts_z => transport_runtime%get_tracer_dep_dist_z(mesh_id, step)
      frac_wind_or_flux => transport_runtime%get_dry_frac_flux_z(mesh_id, step)
      detj_at_w3 => transport_runtime%get_dry_mass(mesh_id, step)

    case default
      call log_event( "ffsl_1d_vert_flux_alg: Unrecognized equation form", LOG_LEVEL_ERROR )
    end select

    if ( order /= 0 ) then
      ! Get objects only needed for high order flux
      dz_w3_rdef => get_dz_w3(mesh_id)
      call dz_w3%initialise( vector_space = field_fs )
      call invoke_copy_to_rtran(dz_w3, dz_w3_rdef)
    end if

    ! Compute fluxes
    select case ( order )
    case ( 0 )
      call invoke( ffsl_flux_z_constant_kernel_type(mass_flux,                 &
                                                    frac_wind_or_flux,         &
                                                    dep_pts_z,                 &
                                                    field_n,                   &
                                                    detj_at_w3,                &
                                                    step_dt) )
    case ( 1 )
      if (reversible) then
        call invoke( ffsl_flux_z_rev_nirvana_kernel_type(mass_flux,            &
                                                         frac_wind_or_flux,    &
                                                         dep_pts_z,            &
                                                         field_n,              &
                                                         dz_w3,                &
                                                         detj_at_w3,           &
                                                         step_dt,              &
                                                         monotone,             &
                                                         log_space) )

      else
        call invoke( ffsl_flux_z_nirvana_kernel_type(mass_flux,                &
                                                     frac_wind_or_flux,        &
                                                     dep_pts_z,                &
                                                     field_n,                  &
                                                     dz_w3,                    &
                                                     detj_at_w3,               &
                                                     step_dt,                  &
                                                     monotone) )

      end if

    case ( 2 )
          call invoke( ffsl_flux_z_ppm_kernel_type(mass_flux,                  &
                                                   frac_wind_or_flux,          &
                                                   dep_pts_z,                  &
                                                   field_n,                    &
                                                   dz_w3,                      &
                                                   detj_at_w3,                 &
                                                   step_dt,                    &
                                                   monotone,                   &
                                                   log_space) )

    case default
      call log_event( "ffsl_1d_vert_flux_alg: order not implemented", LOG_LEVEL_ERROR )
    end select

    nullify( dep_pts_z, detj_at_w3, field_fs,  w2v_fs, dz_w3_rdef, &
             frac_wind_or_flux, transport_runtime, mesh, dry_mass )

  end subroutine ffsl_1d_vert_flux_alg

end module ffsl_vert_alg_mod
