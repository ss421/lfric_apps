!-----------------------------------------------------------------------------
! (c) Crown copyright 2024 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Test the vertical reconstruction functions used for FFSL transport

module subgrid_vertical_support_mod_test

  use constants_mod,                  only: i_def, l_def, r_tran

  implicit none

contains

  !------------------------------------------------------------------

  @test
  subroutine second_order_vertical_edge_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_vertical_support_mod,   only: second_order_vertical_edge

    implicit none

    real(kind=r_tran)   :: rho(1:2), dz(1:2), edge_value, tol
    real(kind=r_tran)   :: answer(1:3)
    integer(kind=i_def) :: edge_to_do

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Test on uniform grid
    dz(1)  = 1.0_r_tran
    dz(2)  = 1.0_r_tran
    rho(1) = 1.0_r_tran
    rho(2) = 3.0_r_tran

    answer(1) = 0.0_r_tran
    answer(2) = 2.0_r_tran
    answer(3) = 4.0_r_tran

    ! Loop over all edges on the rho stencil
    do edge_to_do = 0, 2

      call second_order_vertical_edge(rho, dz,    &
                                      edge_to_do, &
                                      edge_value)

      @assertEqual(answer(edge_to_do+1), edge_value, tol)

    end do

    ! Test on non-uniform grid
    dz(1)  = 1.0_r_tran
    dz(2)  = 2.0_r_tran
    rho(1) = 1.0_r_tran
    rho(2) = 4.0_r_tran

    answer(1) = 0.0_r_tran
    answer(2) = 2.0_r_tran
    answer(3) = 6.0_r_tran

    ! Loop over all edges on the rho stencil
    do edge_to_do = 0, 2

      edge_value = 0.0_r_tran
      call second_order_vertical_edge(rho, dz,    &
                                      edge_to_do, &
                                      edge_value)

      @assertEqual(answer(edge_to_do+1), edge_value, tol)

    end do

  end subroutine second_order_vertical_edge_test

  !------------------------------------------------------------------

  @test
  subroutine second_order_vertical_gradient_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_vertical_support_mod,   only: second_order_vertical_gradient

    implicit none

    real(kind=r_tran) :: rho(1:2), dz(1:2), edge_value, tol
    real(kind=r_tran) :: answer

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Test on uniform grid so gradient should be the difference
    ! of the rho values
    dz(1)  = 1.0_r_tran
    dz(2)  = 1.0_r_tran
    rho(1) = 1.0_r_tran
    rho(2) = 3.0_r_tran

    answer = 2.0_r_tran

    edge_value = 0.0_r_tran
    call second_order_vertical_gradient(rho, &
                                        dz,  &
                                        edge_value)

    @assertEqual(answer, edge_value, tol)

    ! Test on non-uniform grid needs weighted difference
    dz(1)  = 1.0_r_tran
    dz(2)  = 2.0_r_tran
    rho(1) = 1.0_r_tran
    rho(2) = 4.0_r_tran

    answer = 2.0_r_tran

    edge_value = 0.0_r_tran
    call second_order_vertical_gradient(rho, &
                                        dz,  &
                                        edge_value)

    @assertEqual(answer, edge_value, tol)

  end subroutine second_order_vertical_gradient_test

  !------------------------------------------------------------------

  @test
  subroutine fourth_order_vertical_edge_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_vertical_support_mod,   only: fourth_order_vertical_edge

    implicit none

    real(kind=r_tran)   :: rho(1:4), dz(1:4), edge_value, tol
    real(kind=r_tran)   :: answer(1:5)
    integer(kind=i_def) :: edge_to_do

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Test on uniform grid with linear function
    dz(1)  = 1.0_r_tran
    dz(2)  = 1.0_r_tran
    dz(3)  = 1.0_r_tran
    dz(4)  = 1.0_r_tran
    rho(1) = 1.0_r_tran
    rho(2) = 2.0_r_tran
    rho(3) = 3.0_r_tran
    rho(4) = 4.0_r_tran

    answer(1) = 0.5_r_tran
    answer(2) = 1.5_r_tran
    answer(3) = 2.5_r_tran
    answer(4) = 3.5_r_tran
    answer(5) = 4.5_r_tran

    ! Loop over all edges on the rho stencil
    do edge_to_do = 0, 4

      edge_value = 0.0_r_tran
      call fourth_order_vertical_edge(rho,        &
                                      dz,         &
                                      edge_to_do, &
                                      edge_value)

      @assertEqual(answer(edge_to_do+1), edge_value, tol)

    end do

    ! Test on non-uniform grid with linear function
    dz(1)  = 1.0_r_tran
    dz(2)  = 2.0_r_tran
    dz(3)  = 2.0_r_tran
    dz(4)  = 1.0_r_tran
    rho(1) = 1.0_r_tran
    rho(2) = 4.0_r_tran
    rho(3) = 8.0_r_tran
    rho(4) = 11.0_r_tran

    answer(1) = 0.0_r_tran
    answer(2) = 2.0_r_tran
    answer(3) = 6.0_r_tran
    answer(4) = 10.0_r_tran
    answer(5) = 12.0_r_tran

    ! Loop over all edges on the rho stencil
    do edge_to_do = 0, 4

      edge_value = 0.0_r_tran
      call fourth_order_vertical_edge(rho,        &
                                      dz,         &
                                      edge_to_do, &
                                      edge_value)

      @assertEqual(answer(edge_to_do+1), edge_value, tol)

    end do

    ! Test on non-uniform grid with non-linear function
    dz(1)  = 1.0_r_tran
    dz(2)  = 2.0_r_tran
    dz(3)  = 2.0_r_tran
    dz(4)  = 1.0_r_tran
    rho(1) = 1.0_r_tran
    rho(2) = 16.0_r_tran
    rho(3) = 64.0_r_tran
    rho(4) = 121.0_r_tran

    answer(1) = 0.2_r_tran
    answer(2) = 3.2_r_tran
    answer(3) = 34.4_r_tran
    answer(4) = 99.2_r_tran
    answer(5) = 144.2_r_tran

    ! Loop over all edges on the rho stencil
    do edge_to_do = 0, 4

      edge_value = 0.0_r_tran
      call fourth_order_vertical_edge(rho,        &
                                      dz,         &
                                      edge_to_do, &
                                      edge_value)

      @assertEqual(answer(edge_to_do+1), edge_value, tol)

    end do

  end subroutine fourth_order_vertical_edge_test

  !------------------------------------------------------------------

  @test
  subroutine fourth_order_vertical_mono_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_vertical_support_mod,   only: fourth_order_vertical_edge, &
                                              fourth_order_vertical_mono, &
                                              fourth_order_vertical_quasi_mono

    implicit none

    real(kind=r_tran)   :: rho(1:4), dz(1:4), edge_value, tol
    real(kind=r_tran)   :: answer(1:5), answer_qm, dep, min_val
    integer(kind=i_def) :: edge_to_do

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Unlimited fourth order edge tested above, so just test monotonicity
    ! using a uniform grid with a non-linear function
    dz(1)  = 1.0_r_tran
    dz(2)  = 1.0_r_tran
    dz(3)  = 1.0_r_tran
    dz(4)  = 1.0_r_tran
    rho(1) = 0.0_r_tran
    rho(2) = 12.0_r_tran
    rho(3) = 7.0_r_tran
    rho(4) = 4.0_r_tran

    answer(1) = 0.0_r_tran
    answer(2) = 125.0_r_tran/12.0_r_tran
    answer(3) = 10.75_r_tran
    answer(4) = 4.0_r_tran
    answer(5) = 7.0_r_tran

    ! Loop over all edges on the rho stencil
    do edge_to_do = 0, 4

      edge_value = 0.0_r_tran
      call fourth_order_vertical_edge(rho,        &
                                      dz,         &
                                      edge_to_do, &
                                      edge_value)

      call fourth_order_vertical_mono(rho,        &
                                      edge_to_do, &
                                      edge_value)

      @assertEqual(answer(edge_to_do+1), edge_value, tol)

    end do

    ! Now test quasi-monotone edge value - this only applies to
    ! edge = 2

    answer_qm = 10.75_r_tran
    dep = 1.0_r_tran
    min_val = 0.0_r_tran
    edge_to_do = 2

    edge_value = 0.0_r_tran
    call fourth_order_vertical_edge(rho,        &
                                    dz,         &
                                    edge_to_do, &
                                    edge_value)

    call fourth_order_vertical_quasi_mono(rho,     &
                                          dep,     &
                                          min_val, &
                                          edge_value)

    @assertEqual(answer_qm, edge_value, tol)

  end subroutine fourth_order_vertical_mono_test

  !------------------------------------------------------------------

  @test
  subroutine vertical_nirvana_recon_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_vertical_support_mod,   only: vertical_nirvana_recon

    implicit none

    real(kind=r_tran)   :: rho, dz, tol
    real(kind=r_tran)   :: answer, grad_above, grad_below
    real(kind=r_tran)   :: recon, dep_pt

    ! Set tolerance and set unit grid space
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if
    dz  = 1.0_r_tran

    ! Test a linear function
    rho        = 2.0_r_tran
    grad_below = 1.0_r_tran
    grad_above = 1.0_r_tran
    dep_pt     = 0.5_r_tran

    answer = 2.25_r_tran

    call vertical_nirvana_recon(recon,      &
                                dep_pt,     &
                                rho,        &
                                grad_below, &
                                grad_above, &
                                dz)

    @assertEqual(answer, recon, tol)

    ! Test a non-linear function
    rho        = 4.0_r_tran
    grad_below = 2.0_r_tran
    grad_above = -1.0_r_tran
    dep_pt     = 0.5_r_tran

    answer = 4.125_r_tran


    call vertical_nirvana_recon(recon,      &
                                dep_pt,     &
                                rho,        &
                                grad_below, &
                                grad_above, &
                                dz)

    @assertEqual(answer, recon, tol)

  end subroutine vertical_nirvana_recon_test

  !------------------------------------------------------------------

  @test
  subroutine vertical_nirvana_mono_strict_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_vertical_support_mod,   only: vertical_nirvana_recon, &
                                              vertical_nirvana_mono_strict

    implicit none

    real(kind=r_tran)   :: rho(1:3), dz, tol
    real(kind=r_tran)   :: answer, grad_above, grad_below
    real(kind=r_tran)   :: recon, dep_pt

    ! Set tolerance and set unit grid space
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if
    dz  = 1.0_r_tran

    ! Test a non-linear function with strict monotonicity
    rho(1)     = 0.0_r_tran
    rho(2)     = 4.0_r_tran
    rho(3)     = 3.0_r_tran
    grad_below = 4.0_r_tran
    grad_above = -1.0_r_tran
    dep_pt     = 0.5_r_tran

    ! Unlimited reconstruction is 4.125, limit should change this to 4
    answer = 4.0_r_tran
    call vertical_nirvana_recon(recon,      &
                                dep_pt,     &
                                rho(2),     &
                                grad_below, &
                                grad_above, &
                                dz)

    call vertical_nirvana_mono_strict(recon,      &
                                      rho,        &
                                      grad_below, &
                                      grad_above, &
                                      dz)

    @assertEqual(answer, recon, tol)

  end subroutine vertical_nirvana_mono_strict_test

  !------------------------------------------------------------------

  @test
  subroutine vertical_nirvana_mono_relax_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_vertical_support_mod,   only: vertical_nirvana_recon, &
                                              vertical_nirvana_mono_relax

    implicit none

    real(kind=r_tran)   :: rho(1:3), dz, tol
    real(kind=r_tran)   :: answer, grad_above, grad_below
    real(kind=r_tran)   :: recon, dep_pt

    ! Set tolerance and set unit grid space
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if
    dz  = 1.0_r_tran

    ! Test a non-linear function with relaxed monotonicity options
    rho(1)     = 0.0_r_tran
    rho(2)     = 4.0_r_tran
    rho(3)     = 2.0_r_tran
    grad_below = 2.0_r_tran
    grad_above = -1.0_r_tran
    dep_pt     = 0.5_r_tran

    answer = 4.0_r_tran
    call vertical_nirvana_recon(recon,      &
                                dep_pt,     &
                                rho(2),     &
                                grad_below, &
                                grad_above, &
                                dz)

    call vertical_nirvana_mono_relax(recon,      &
                                     dep_pt,     &
                                     rho,        &
                                     grad_below, &
                                     grad_above, &
                                     dz)

    @assertEqual(answer, recon, tol)

  end subroutine vertical_nirvana_mono_relax_test

  !------------------------------------------------------------------

  @test
  subroutine vertical_nirvana_positive_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_vertical_support_mod,   only: vertical_nirvana_recon, &
                                              vertical_nirvana_positive

    implicit none

    real(kind=r_tran)   :: rho, dz, tol
    real(kind=r_tran)   :: answer, grad_above, grad_below
    real(kind=r_tran)   :: recon, dep_pt

    ! Set tolerance and set unit grid space
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if
    dz  = 1.0_r_tran

    ! Test a non-linear function with positivity
    rho        = 0.1_r_tran
    grad_below = -4.0_r_tran
    grad_above = 0.0_r_tran
    dep_pt     = 0.1_r_tran

    ! Without positivity the recon=-0.56, with positivty the
    ! recon should revert to the rho value of 0.1
    answer = 0.1_r_tran
    call vertical_nirvana_recon(recon,      &
                                dep_pt,     &
                                rho,        &
                                grad_below, &
                                grad_above, &
                                dz)

    call vertical_nirvana_positive(recon,      &
                                   rho,        &
                                   grad_below, &
                                   grad_above, &
                                   dz)

    @assertEqual(answer, recon, tol)

  end subroutine vertical_nirvana_positive_test

  !------------------------------------------------------------------

  @test
  subroutine vertical_ppm_recon_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_vertical_support_mod,   only: vertical_ppm_recon

    implicit none

    real(kind=r_tran)   :: rho, rho_L, rho_R, tol
    real(kind=r_tran)   :: answer, recon, dep_pt

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Test a quadratic function
    rho_L    = 0.0_r_tran
    rho_R    = 8.0_r_tran
    rho      = 1.0_r_tran
    dep_pt   = 0.5_r_tran

    answer = 3.0_r_tran

    call vertical_ppm_recon(recon,    &
                            dep_pt,   &
                            rho,      &
                            rho_L,    &
                            rho_R)

    @assertEqual(answer, recon, tol)

    ! Test a non-linear function
    rho_L    = 0.0_r_tran
    rho_R    = 1.0_r_tran
    rho      = 2.0_r_tran
    dep_pt   = 0.5_r_tran

    answer = 2.25_r_tran

    call vertical_ppm_recon(recon,    &
                            dep_pt,   &
                            rho,      &
                            rho_L,    &
                            rho_R)

    @assertEqual(answer, recon, tol)

  end subroutine vertical_ppm_recon_test

  !------------------------------------------------------------------

  @test
  subroutine vertical_ppm_mono_strict_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_vertical_support_mod,   only: vertical_ppm_recon, &
                                              vertical_ppm_mono_strict

    implicit none

    real(kind=r_tran)   :: rho, rho_L, rho_R, tol
    real(kind=r_tran)   :: answer, recon, dep_pt

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Test a non-linear function with strict monotonicity
    rho_L    = 0.0_r_tran
    rho_R    = 1.0_r_tran
    rho      = 2.0_r_tran
    dep_pt   = 0.5_r_tran

    answer = 2.0_r_tran

    call vertical_ppm_recon(recon,  &
                            dep_pt, &
                            rho,    &
                            rho_L,  &
                            rho_R)

    call vertical_ppm_mono_strict(recon,  &
                                  rho,    &
                                  rho_L,  &
                                  rho_R)

    @assertEqual(answer, recon, tol)

  end subroutine vertical_ppm_mono_strict_test

  !------------------------------------------------------------------

  @test
  subroutine vertical_ppm_mono_relax_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_vertical_support_mod,   only: vertical_ppm_recon, &
                                              vertical_ppm_mono_relax

    implicit none

    real(kind=r_tran)   :: rho, rho_L, rho_R, tol
    real(kind=r_tran)   :: answer, recon, dep_pt

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Test a non-linear function with relaxed monotonicity
    rho_L    = 0.0_r_tran
    rho_R    = 1.0_r_tran
    rho      = 2.0_r_tran
    dep_pt   = 0.5_r_tran

    answer = 2.0_r_tran

    call vertical_ppm_recon(recon,  &
                            dep_pt, &
                            rho,    &
                            rho_L,  &
                            rho_R)

    call vertical_ppm_mono_relax(recon,  &
                                 dep_pt, &
                                 rho,    &
                                 rho_L,  &
                                 rho_R)

    @assertEqual(answer, recon, tol)

  end subroutine vertical_ppm_mono_relax_test

  !------------------------------------------------------------------

  @test
  subroutine vertical_ppm_positive_test()
    use pFUnit_Mod
    use, intrinsic :: iso_fortran_env,  only: real64
    use subgrid_vertical_support_mod,   only: vertical_ppm_recon, &
                                              vertical_ppm_positive

    implicit none

    real(kind=r_tran)   :: rho, rho_L, rho_R, tol
    real(kind=r_tran)   :: answer, recon, dep_pt

    ! Set tolerance
    if ( r_tran == real64 ) then
      tol = 1.0e-12_r_tran
    else
      tol = 1.0e-6_r_tran
    end if

    ! Test a non-linear function with positivity
    rho_L    = 1.0_r_tran
    rho_R    = 1.0_r_tran
    rho      = 0.1_r_tran
    dep_pt   = 0.1_r_tran

    ! Without positivity the recon=0.7480, with positivty the
    ! recon should revert to the rho value of 0.1
    answer = 0.1_r_tran

    call vertical_ppm_recon(recon,  &
                            dep_pt, &
                            rho,    &
                            rho_L,  &
                            rho_R)

    call vertical_ppm_positive(recon,  &
                               dep_pt, &
                               rho,    &
                               rho_L,  &
                               rho_R)

    @assertEqual(answer, recon, tol)

  end subroutine vertical_ppm_positive_test

  !------------------------------------------------------------------

end module subgrid_vertical_support_mod_test