!-----------------------------------------------------------------------------
! (c) Crown copyright 2024 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Test the tracer 1D FFSL first order flux computation in the horizontal

module ffsl_flux_xy_first_kernel_mod_test

  use constants_mod, only : i_def, r_tran
  use pFUnit_Mod

  implicit none

  private

  public :: test_all

contains

 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test
  subroutine test_all( )

    use, intrinsic :: iso_fortran_env,  only: real64
    use ffsl_flux_xy_first_kernel_mod,  only: ffsl_flux_xy_first_code
    use reference_element_mod,          only : W, E, N, S

    implicit none

    real(kind=r_tran), parameter :: tol = 1.0e-12_r_tran   ! r_tran 64-bit
    real(kind=r_tran)            :: answer, use_tol

    integer(kind=i_def), parameter :: nlayers = 1
    integer(kind=i_def), parameter :: ndf_w3 = 1
    integer(kind=i_def), parameter :: ndf_w2 = 4
    integer(kind=i_def), parameter :: stencil_size = 3
    integer(kind=i_def), parameter :: undf_w2 = ndf_w2*nlayers
    integer(kind=i_def), parameter :: undf_w3 = ndf_w3*nlayers*stencil_size

    integer(kind=i_def), dimension(ndf_w3)              :: map_w3
    integer(kind=i_def), dimension(ndf_w2)              :: map_w2
    integer(kind=i_def), dimension(ndf_w3,stencil_size) :: stencil_map

    real(kind=r_tran),   dimension(undf_w3) :: field_for_x
    real(kind=r_tran),   dimension(undf_w3) :: field_for_y
    real(kind=r_tran),   dimension(undf_w2) :: flux
    real(kind=r_tran),   dimension(undf_w2) :: frac_dry_flux
    integer(kind=i_def), dimension(undf_w3) :: face_selector_ew
    integer(kind=i_def), dimension(undf_w3) :: face_selector_ns

    real(kind=r_tran)   :: dt

    ! Set up maps
    stencil_map(1,:) = (/ 2, 1, 3 /)
    map_w2(:) = (/ 1, 2, 3, 4 /)
    map_w3(1) = 1

    ! Set up both fields to have quadratic profile
    field_for_x(:) = (/ 1.0_r_tran, 2.0_r_tran, 3.0_r_tran /)
    field_for_y(:) = (/ 4.0_r_tran, 5.0_r_tran, 6.0_r_tran /)

    ! The face_selector tells the kernel how many faces to compute the fluxes on.
    ! Setting each face selector to 2 ensures the kernel will compute all the
    ! horizontal fluxes in the cell
    face_selector_ew(:) = 2
    face_selector_ns(:) = 2

    ! Initialise flux to zero before each test
    flux(:) = 0.0_r_tran

    ! Test with positive dry flux
    frac_dry_flux(:) = 3.0_r_tran
    dt = 1.0_r_tran
    call ffsl_flux_xy_first_code( nlayers,          &
                                  flux,             &
                                  field_for_x,      &
                                  stencil_size,     &
                                  stencil_map,      &
                                  field_for_y,      &
                                  stencil_size,     &
                                  stencil_map,      &
                                  frac_dry_flux,    &
                                  face_selector_ew, &
                                  face_selector_ns, &
                                  dt,               &
                                  ndf_w2,           &
                                  undf_w2,          &
                                  map_w2,           &
                                  ndf_w3,           &
                                  undf_w3,          &
                                  map_w3,           &
                                  ndf_w3,           &
                                  undf_w3,          &
                                  map_w3 )
    ! Get correct tolerance
    if ( r_tran == real64 ) then
      use_tol = tol
    else
      use_tol = 10.0_r_tran*spacing( maxval( flux(:) ) )
    end if
    answer = 3.0_r_tran
    @assertEqual(answer, flux(W), use_tol)
    answer = 15.0_r_tran
    @assertEqual(answer, flux(S), use_tol)
    answer = 6.0_r_tran
    @assertEqual(answer, flux(E), use_tol)
    answer = 18.0_r_tran
    @assertEqual(answer, flux(N), use_tol)

    ! Initialise flux to zero before each test
    flux(:) = 0.0_r_tran

    ! Test with negative dry flux distance
    frac_dry_flux(:) = -3.0_r_tran
    dt = 1.0_r_tran
    call ffsl_flux_xy_first_code( nlayers,          &
                                  flux,             &
                                  field_for_x,      &
                                  stencil_size,     &
                                  stencil_map,      &
                                  field_for_y,      &
                                  stencil_size,     &
                                  stencil_map,      &
                                  frac_dry_flux,    &
                                  face_selector_ew, &
                                  face_selector_ns, &
                                  dt,               &
                                  ndf_w2,           &
                                  undf_w2,          &
                                  map_w2,           &
                                  ndf_w3,           &
                                  undf_w3,          &
                                  map_w3,           &
                                  ndf_w3,           &
                                  undf_w3,          &
                                  map_w3 )
    ! Get correct tolerance
    if ( r_tran == real64 ) then
      use_tol = tol
    else
      use_tol = 10.0_r_tran*spacing( maxval( flux(:) ) )
    end if
    answer = -6.0_r_tran
    @assertEqual(answer, flux(W), use_tol)
    answer = -12.0_r_tran
    @assertEqual(answer, flux(S), use_tol)
    answer = -9.0_r_tran
    @assertEqual(answer, flux(E), use_tol)
    answer = -15.0_r_tran
    @assertEqual(answer, flux(N), use_tol)

  end subroutine test_all

end module ffsl_flux_xy_first_kernel_mod_test
